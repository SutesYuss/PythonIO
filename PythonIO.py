
import re

# ----------------
#  Argument Types
# ----------------

def printargs0(x, y=0, /, *, z, w):
	print(f"{x = }")
	print(f"{y = }")
	print(f"{z = }")
	print(f"{w = }")

# TODO call the function printargs0
#call to printargs0
# printargs0(1,z=3,w=6);


# TODO change the signature of printargs1 to take four arguments, all with default values
def printargs1(x=3, y=0, z=5, w=4):
	print(f"{x = }")
	print(f"{y = }")
	print(f"{z = }")
	print(f"{w = }")


# TODO call the function printargs1

#call to printargs1
# printargs1();


# TODO change the signature of printargs2 to take:
#   * one positional-only argument
#   * two positional-or-keyword arguments
#   * three keyword-only arguments
def printargs2(x, /, y, s, *, z, w, v):
	# TODO implement the body of printargs2 to print the name and value of each argument	
  print(f"{x = }")
  print(f"{y = }")
  print(f"{s = }")
  print(f"{z = }")
  print(f"{w = }")
  print(f"{v = }")

# TODO call the function printargs2
# printargs2(3, 5, s=6, z=5, w=4, v=2);

# TODO change the signature of printargs3 to take four positional-only arguments
def printargs3(x,y,z,w):
	print(f"{x = }")
	print(f"{y = }")
	print(f"{z = }")
	print(f"{w = }")


# TODO call the function printargs3
# printargs3(1,2,3,4)

# TODO change the signature of printargs4 to take a variadic argument list
def printargs4(*args):
  for x in args: 
    print(x)

# TODO call the function printargs4
# printargs4(1,2,3,4,[5,6])

# TODO change the signature of printargs5 to take a keyword-variadic argument
def printargs5(**args):
  for x in args: 
    print(f"{x} = {args[x]} ")


# TODO call the function printargs5
# printargs5(x=1, y=2, z=3, w=4, v=[5,6]);

# --------------
#  Dictionaries
# --------------

"""Returns a dictionary in which each item in `keys` maps to the corresponding item in `values`.

Uses a for-in loop.

Args:
  keys: the list of keys
  values: the list of values
"""
def build_dict1(keys, values):
  i = 0;
  mydict = {};
  for k in keys:
    mydict[keys[i]] = values[i]
    i = i + 1;
  return mydict 

# keys = ['A','B','C'];
# values = [1,2,3];
# print(build_dict1(keys,values));
"""Returns a dictionary in which each item in `keys` maps to the corresponding item in `values`.

Uses a dictionary comprehension.

Args:
  keys: the list of keys
  values: the list of valu
  es
"""
def build_dict2(keys, values):

  mydict ={keys[x]: values[x] for x in range(len(keys))}
  return mydict
  


# keys1 = ['A','B','C'];
# values1 = [1,2,3];
# print(build_dict2(keys1,values1));


"""Returns a dictionary in which each item in `keys` maps to the corresponding item in `values`.

Uses the built-in `zip(seq1, seq2)` function.

Args:
  keys: the list of keys
  values: the list of values
"""
def build_dict3(keys, values):
  return dict(zip(keys,values));
    

# keys2 = ['A','B','C'];
# values2 = [1,2,3];
# print(build_dict3(keys2,values2));

"""Returns a dictionary which maps each letter to the number of times it appears in `s`.

Args:
  s: the string in which to search
"""
def letter_freq(s: str) -> dict:
  str2 = str.upper();
  alphaDict = {}
  for letter in str2:
    alphaDict[letter] = alphaDict.get(letter.upper(),0) + 1;
  return alphaDict

str = "Hello"
print(letter_freq(str));


"""Returns the letter in `s` that appears most often.

Args:
  s: the string in which to search
"""
def popular_letter(s: str) -> str:
  letterMap = letter_freq(str);
  x = max(letterMap.values());

  for char in letterMap:
    if (letterMap.get(char) == x):
      return char


# print(popular_letter(str))

# ------------------------
#  Generators and Lambdas
# ------------------------

"""Generates the series identified by the Collatz Conjecture starting at `x`.

Args:
  x: the starting number
"""
def collatz(x):
  while x != 1:
    yield x
    if x % 2 == 0:
      x = x // 2
    else:
     x = 3*x + 1
  yield x

"""Returns the length of the series generated by `collatz(x)`."""
def collatz_len(x):
  j = 0;
  for i in collatz(x):
    j = j+1;
  return j

# print(collatz_len(10));

"""Generates the sequence of words in string `s`."""
def words(s):
  wordList = re.findall(r'\w+', s)
  for x in wordList:
    yield x


"""Returns a list created by applying the single-argument function `f` to each item in `lst`.

Args:
  lst: the list
  f: a single-argument function that is applicable to each item in lst
"""
def mapped_list(lst, f):
  i = len(lst);
  while i >0:
    x = lst[0];
    lst.append(f(x));
    lst.remove(x);
    i = i-1;

  return lst;


# TODO Call `mapped_list` with a lambda expression such that the generated list consists of the 
#   length of the Collatz Conjecture seires generated starting at the corresponding number in `lst`.

mapped_list([10,2,3,4], lambda x: collatz_len(x));

# ----------------------
#  Challenge Activities
# ----------------------

# TODO Fiddle with the apparently-arbitrary values in the `mcg` function and see if the results can
#   be made significantly better or worse by changing them.

"""Simple pseudorandom number generator."""
def mcg(s=543718):
    x = s
    a = 48271
    c = 1
    m = 2147483647
    while True:
        x = (a*x + c) % m
        yield x

"""Simulates rolling a `sides`-sided die `samples` times, and prints the results.

Args:
  sides: number of sides on the die to simulate
  samples: number of rolls to simulate
"""
def diceroller(sides=6, samples=10000):
  die = (n % sides + 1 for n in mcg())
  counts = dict()
  for i in range(samples):
        roll = next(die)
        if roll not in counts:
            counts[roll] = 0
        counts[roll] += 1
            
    # TODO Modify the output of this function so that it displays a "pretty" horizontal bar chart.
    #   Hint: use the Unicode character FULL BLOCK (U+2588) (in Python: u"\u2588").
  for value in range(1, sides + 1):
        print(f"{value}: {counts[value]}")

